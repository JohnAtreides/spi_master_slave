// Project: Nokia5110 - Controlling a NK5110 display from an NXP LPC1768
// File: NOKIA_5110.cpp
// Author: Chris Yan
// Created: January, 2012
// Revised: January, 2014
//  Desc: Supporting code for the NokiaLcd class

#include "PCD8544.h"
#include "mbed.h"




// a simple bitmap character set
const char FONT_6x6[570] = //should be 564 total char
{
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // SPACE   1   
 0x00, 0x06, 0x2F, 0x06, 0x00, 0x00, // !   2
 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, // "   3
 0x14, 0x3E, 0x14, 0x3E, 0x14, 0x00, // #   4
 0x2E, 0x2A, 0x3F, 0x2A, 0x3A, 0x00, // $   5
 0x26, 0x16, 0x08, 0x34, 0x32, 0x00, // %   6
 0x34, 0x2A, 0x3C, 0x18, 0x28, 0x00, // &   7
 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, // '   8
 0x00, 0x00, 0x1C, 0x36, 0x22, 0x00, // (   9
 0x22, 0x36, 0x1C, 0x00, 0x00, 0x00, // )   10
 0x24, 0x18, 0x0E, 0x18, 0x24, 0x00, // *   11
 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, // +   12
 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, // ,   13
 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, // -   14
 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, // .   15
 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, // /   16
 0x00, 0x1C, 0x22, 0x22, 0x1C, 0x00, // 0   17
 0x00, 0x24, 0x3E, 0x20, 0x00, 0x00, // 1   18
 0x3A, 0x2A, 0x2A, 0x2A, 0x2E, 0x00, // 2   19
 0x22, 0x2A, 0x2A, 0x2A, 0x3E, 0x00, // 3   20
 0x0E, 0x08, 0x08, 0x3E, 0x08, 0x00, // 4   21
 0x2E, 0x2A, 0x2A, 0x2A, 0x3A, 0x00, // 5   22
 0x3E, 0x2A, 0x2A, 0x2A, 0x3A, 0x00, // 6   23
 0x22, 0x12, 0x0A, 0x06, 0x02, 0x00, // 7   24
 0x3E, 0x2A, 0x2A, 0x2A, 0x3E, 0x00, // 8   25
 0x00, 0x2E, 0x2A, 0x2A, 0x3E, 0x00, // 9   26
 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, // :   27
 0x00, 0x20, 0x14, 0x00, 0x00, 0x00, // ;   28
 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, // <   29
 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, // =   30
 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, // >   31
 0x06, 0x01, 0x2D, 0x06, 0x00, 0x00, // ?   32
 0x1E, 0x23, 0x19, 0x35, 0x3E, 0x00, // @   33
 0x3C, 0x0A, 0x0A, 0x0A, 0x3C, 0x00, // A   34
 0x3E, 0x2A, 0x2A, 0x2A, 0x1C, 0x00, // B   35
 0x1C, 0x22, 0x22, 0x22, 0x22, 0x00, // C   36
 0x3E, 0x22, 0x22, 0x22, 0x1C, 0x00, // D   37
 0x3E, 0x2A, 0x2A, 0x2A, 0x22, 0x00, // E   38
 0x3E, 0x0A, 0x0A, 0x0A, 0x02, 0x00, // F   39
 0x1C, 0x22, 0x2A, 0x2A, 0x18, 0x00, // G   40
 0x3E, 0x08, 0x08, 0x08, 0x3E, 0x00, // H
 0x22, 0x22, 0x3E, 0x22, 0x22, 0x00, // I
 0x10, 0x22, 0x22, 0x1E, 0x02, 0x00, // J
 0x3E, 0x08, 0x14, 0x22, 0x00, 0x00, // K
 0x00, 0x3E, 0x20, 0x20, 0x20, 0x00, // L   45
 0x3E, 0x04, 0x08, 0x04, 0x3E, 0x00, // M
 0x3C, 0x02, 0x02, 0x02, 0x3C, 0x00, // N
 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, // O
 0x3E, 0x0A, 0x0A, 0x04, 0x00, 0x00, // P
 0x1C, 0x22, 0x32, 0x3C, 0x20, 0x00, // Q   50
 0x3E, 0x0A, 0x0A, 0x1A, 0x24, 0x00, // R
 0x24, 0x2A, 0x2A, 0x2A, 0x12, 0x00, // S
 0x02, 0x02, 0x3E, 0x02, 0x02, 0x00, // T
 0x1E, 0x20, 0x20, 0x20, 0x1E, 0x00, // U
 0x06, 0x18, 0x20, 0x18, 0x06, 0x00, // V   55
 0x0E, 0x30, 0x18, 0x30, 0x0E, 0x00, // W
 0x22, 0x14, 0x08, 0x14, 0x22, 0x00, // X
 0x02, 0x04, 0x38, 0x04, 0x02, 0x00, // Y
 0x22, 0x32, 0x2A, 0x26, 0x22, 0x00, // Z
 0x00, 0x00, 0x00, 0x3E, 0x22, 0x00, // [   60
 0x06, 0x0C, 0x18, 0x30, 0x00, 0x00, // backslash
 0x22, 0x3E, 0x00, 0x00, 0x00, 0x00, // ]
 0x00, 0x04, 0x02, 0x02, 0x04, 0x00, // ^
 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, // _
 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, // `   65
 0x18, 0x24, 0x14, 0x38, 0x00, 0x00, // a
 0x1E, 0x28, 0x28, 0x10, 0x00, 0x00, // b
 0x18, 0x24, 0x24, 0x00, 0x00, 0x00, // c
 0x10, 0x28, 0x28, 0x1E, 0x00, 0x00, // d
 0x18, 0x2C, 0x2C, 0x08, 0x00, 0x00, // e   70
 0x00, 0x3C, 0x12, 0x04, 0x00, 0x00, // f
 0x24, 0x2A, 0x1E, 0x00, 0x00, 0x00, // g
 0x3E, 0x08, 0x30, 0x00, 0x00, 0x00, // h
 0x00, 0x3A, 0x00, 0x00, 0x00, 0x00, // i
 0x10, 0x20, 0x1A, 0x00, 0x00, 0x00, // j   75
 0x3E, 0x10, 0x2C, 0x20, 0x00, 0x00, // k
 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, // l
 0x38, 0x08, 0x18, 0x08, 0x30, 0x00, // m
 0x30, 0x08, 0x08, 0x30, 0x00, 0x00, // n
 0x10, 0x28, 0x28, 0x10, 0x00, 0x00, // o   80
 0x38, 0x14, 0x14, 0x08, 0x00, 0x00, // p
 0x08, 0x14, 0x14, 0x38, 0x00, 0x00, // q
 0x3C, 0x08, 0x04, 0x00, 0x00, 0x00, // r
 0x2C, 0x34, 0x00, 0x00, 0x00, 0x00, // s
 0x08, 0x3C, 0x28, 0x00, 0x00, 0x00, // t   85
 0x18, 0x20, 0x20, 0x18, 0x00, 0x00, // u
 0x08, 0x10, 0x20, 0x10, 0x08, 0x00, // v
 0x18, 0x20, 0x10, 0x20, 0x18, 0x00, // w
 0x28, 0x10, 0x28, 0x00, 0x00, 0x00, // x
 0x2C, 0x30, 0x1C, 0x00, 0x00, 0x00, // y   90
 0x24, 0x34, 0x2C, 0x24, 0x00, 0x00, // z
 0x00, 0x00, 0x08, 0x3E, 0x22, 0x00, // {
 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, // |
 0x22, 0x3E, 0x08, 0x00, 0x00, 0x00, // }
 0x10, 0x08, 0x18, 0x10, 0x08, 0x00, // ~   95
};




// Command Instructions
//       H = 0
#define CMD_DC_CLEAR_DISPLAY   0x08
#define CMD_DC_NORMAL_MODE     0x0C
#define CMD_DC_FILL_DISPLAY    0x09
#define CMD_DC_INVERT_VIDEO    0x0D
#define CMD_FS_HORIZONTAL_MODE 0x00
#define CMD_FS_VERTICAL_MODE   0x02
#define CMD_FS_BASIC_MODE      0x00
#define CMD_FS_EXTENDED_MODE   0x01
#define CMD_FS_ACTIVE_MODE     0x00
#define CMD_FS_POWER_DOWN_MODE 0x04
//       H = 1
#define CMD_TC_TEMP_0          0x04
#define CMD_TC_TEMP_1          0x05
#define CMD_TC_TEMP_2          0x06
#define CMD_TC_TEMP_3          0x07
#define CMD_BI_MUX_24          0x15
#define CMD_BI_MUX_48          0x13
#define CMD_BI_MUX_100         0x10
#define CMD_VOP_6V06           0xB2
#define CMD_VOP_7V38           0xC8


// LCD Characteristics

#define LCD_X_MAX 84
#define LCD_Y_MAX 48

PCD8544::PCD8544(PinName mosi, PinName sclk,PinName dc, PinName sce,PinName rst,PinName power, PinName led) :
		spi(mosi, NC, sclk), pin_rst(rst),pin_sce(sce),pin_dc(dc),pin_power(power),pin_backlight(led)
{


    // finish Spi initialisation
    spi.format(8, 3); // 8 bits, mode 3
    spi.frequency(2000000);

    
    // Initial Command Instructions, note the initial command mode
    functionSet.V   = CMD_FS_HORIZONTAL_MODE;
    functionSet.H   = CMD_FS_EXTENDED_MODE;
    functionSet.PD  = CMD_FS_ACTIVE_MODE;
    functionChar    = createFunctionChar();
    
    // Operational parameters, MUX 100, VOP 7.38V, Temperature coefficient 2
    tempControlChar = CMD_TC_TEMP_0;
    dispControlChar = CMD_DC_NORMAL_MODE;
    biasChar        = CMD_BI_MUX_100;
    vopChar         = CMD_VOP_7V38;
}

void PCD8544::shutdown()
{
    

    clear();
    sendFunction( CMD_DC_CLEAR_DISPLAY );

    functionSet.PD  = CMD_FS_POWER_DOWN_MODE;
    sendFunction( createFunctionChar() );
    
    // simply power down
    pin_power=0;
    pin_backlight =0;

}



void PCD8544::setBacklight(bool on){
    pin_backlight=on;
}

void PCD8544::activate()
{
    // power and reset cycle
    pin_power=0; // in case it isn't off
    ThisThread::sleep_for(1);
    pin_power=1; // power on
    ThisThread::sleep_for(10);
    pin_rst=0;   // Reset goes low
    ThisThread::sleep_for(10);
    pin_rst=1;   // Reset goes high
    pin_sce=0;   // Chip Select goes low
    
    // Redefine the functionChar in case it has changed
    functionSet.V   = CMD_FS_HORIZONTAL_MODE;
    functionSet.H   = CMD_FS_EXTENDED_MODE;
    functionSet.PD  = CMD_FS_ACTIVE_MODE;
    sendFunction( createFunctionChar() );   // Extended CMD set
    sendFunction( vopChar );                // | Vop
    sendFunction( tempControlChar );        // | Temp
    sendFunction( biasChar );               // | Bias

    functionSet.H   = CMD_FS_BASIC_MODE;
    sendFunction( createFunctionChar() );   // Basic CMD set
    sendFunction( dispControlChar );        // | Display Mode
    
    clear(); // clear screen
    pin_dc = 1;  // Data/CMD goes back to Data mode
}

char PCD8544::createFunctionChar()
{
    return ( 0x20 | functionSet.PD | functionSet.V | functionSet.H );
}





// TODO this is highly inefficient, use buffer and transfer instead
void PCD8544::clear()
{
    for(int tick = 0; tick <= 503; tick++)
        spi.write(0x00);
}

// TODO this is highly inefficient, use buffer and transfer instead
void PCD8544::drawString(const char *s)
{
    char len = strlen(s);
    for( int idx = 0; idx < len; idx++ )
    {
        for( int i = 0; i < 6; i++)
            sendDrawData( FONT_6x6[ ((s[idx] - 32)*6) + i] );
    }
}
void PCD8544::sendDrawData(char data)
{
    spi.write(data);         // Command gets sent
}



void PCD8544::setXY(char x, char y)
{
    if( (x > 83) || (y > 5) )
        return;

    sendFunction( x | 0x80 );
    sendFunction( y | 0x40 );
}

void PCD8544::sendFunction(char cmd) //TODO:Detection of what H should be
{
    pin_dc=0;     // Data/CMD goes low
    spi.write(cmd);     // Command gets sent
    pin_dc=1;     // Data/CMD goes back to Data mode
}

PCD8544::~PCD8544()
{
    shutdown();
}
